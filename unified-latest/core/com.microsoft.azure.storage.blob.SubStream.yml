### YamlMime:ManagedReference
items:
- uid: "com.microsoft.azure.storage.blob.SubStream"
  id: "SubStream"
  parent: "com.microsoft.azure.storage.blob"
  children:
  - "com.microsoft.azure.storage.blob.SubStream.SubStream(java.io.InputStream,long,long,java.lang.Object)"
  - "com.microsoft.azure.storage.blob.SubStream.close()"
  - "com.microsoft.azure.storage.blob.SubStream.getInputStream()"
  - "com.microsoft.azure.storage.blob.SubStream.getLength()"
  - "com.microsoft.azure.storage.blob.SubStream.mark(int)"
  - "com.microsoft.azure.storage.blob.SubStream.markSupported()"
  - "com.microsoft.azure.storage.blob.SubStream.read()"
  - "com.microsoft.azure.storage.blob.SubStream.read(byte[])"
  - "com.microsoft.azure.storage.blob.SubStream.read(byte[],int,int)"
  - "com.microsoft.azure.storage.blob.SubStream.reset()"
  - "com.microsoft.azure.storage.blob.SubStream.skip(long)"
  langs:
  - "java"
  name: "SubStream"
  nameWithType: "SubStream"
  fullName: "com.microsoft.azure.storage.blob.SubStream"
  type: "Class"
  package: "com.microsoft.azure.storage.blob"
  syntax:
    content: "public class SubStream extends InputStream"
  inheritance:
  - "java.lang.Object"
  - "java.io.InputStream"
  inheritedMembers:
  - "java.io.InputStream.available()"
  - "java.io.InputStream.close()"
  - "java.io.InputStream.mark(int)"
  - "java.io.InputStream.markSupported()"
  - "java.io.InputStream.nullInputStream()"
  - "java.io.InputStream.read()"
  - "java.io.InputStream.read(byte[])"
  - "java.io.InputStream.read(byte[],int,int)"
  - "java.io.InputStream.readAllBytes()"
  - "java.io.InputStream.readNBytes(byte[],int,int)"
  - "java.io.InputStream.readNBytes(int)"
  - "java.io.InputStream.reset()"
  - "java.io.InputStream.skip(long)"
  - "java.io.InputStream.transferTo(java.io.OutputStream)"
  - "java.lang.Object.clone()"
  - "java.lang.Object.equals(java.lang.Object)"
  - "java.lang.Object.finalize()"
  - "java.lang.Object.getClass()"
  - "java.lang.Object.hashCode()"
  - "java.lang.Object.notify()"
  - "java.lang.Object.notifyAll()"
  - "java.lang.Object.toString()"
  - "java.lang.Object.wait()"
  - "java.lang.Object.wait(long)"
  - "java.lang.Object.wait(long,int)"
- uid: "com.microsoft.azure.storage.blob.SubStream.SubStream(java.io.InputStream,long,long,java.lang.Object)"
  id: "SubStream(java.io.InputStream,long,long,java.lang.Object)"
  parent: "com.microsoft.azure.storage.blob.SubStream"
  langs:
  - "java"
  name: "SubStream(InputStream source, long startIndex, long streamLength, Object lock)"
  nameWithType: "SubStream.SubStream(InputStream source, long startIndex, long streamLength, Object lock)"
  fullName: "com.microsoft.azure.storage.blob.SubStream.SubStream(InputStream source, long startIndex, long streamLength, Object lock)"
  overload: "com.microsoft.azure.storage.blob.SubStream.SubStream*"
  type: "Constructor"
  package: "com.microsoft.azure.storage.blob"
  summary: "Creates a new substream instance that partitions the wrapped stream `source` from `startIndex` up to `streamLength`. Each substream instance that wraps the same underlying `InputStream` must share the same mutual exclusion `lock` to avoid race conditions from concurrent operations."
  syntax:
    content: "public SubStream(InputStream source, long startIndex, long streamLength, Object lock)"
    parameters:
    - id: "source"
      type: "java.io.InputStream"
      description: "The markable InputStream to be wrapped."
    - id: "startIndex"
      type: "long"
      description: "A valid index in the wrapped stream where the substream should logically begin."
    - id: "streamLength"
      type: "long"
      description: "The length of the substream."
    - id: "lock"
      type: "java.lang.Object"
      description: "An intrinsic lock to ensure thread-safe, concurrent operations\n                     on substream instances wrapping the same InputStream."
- uid: "com.microsoft.azure.storage.blob.SubStream.close()"
  id: "close()"
  parent: "com.microsoft.azure.storage.blob.SubStream"
  langs:
  - "java"
  name: "close()"
  nameWithType: "SubStream.close()"
  fullName: "com.microsoft.azure.storage.blob.SubStream.close()"
  overload: "com.microsoft.azure.storage.blob.SubStream.close*"
  type: "Method"
  package: "com.microsoft.azure.storage.blob"
  summary: "Closes the substream."
  syntax:
    content: "public void close()"
  exceptions:
  - type: "java.io.IOException"
- uid: "com.microsoft.azure.storage.blob.SubStream.getInputStream()"
  id: "getInputStream()"
  parent: "com.microsoft.azure.storage.blob.SubStream"
  langs:
  - "java"
  name: "getInputStream()"
  nameWithType: "SubStream.getInputStream()"
  fullName: "com.microsoft.azure.storage.blob.SubStream.getInputStream()"
  overload: "com.microsoft.azure.storage.blob.SubStream.getInputStream*"
  type: "Method"
  package: "com.microsoft.azure.storage.blob"
  syntax:
    content: "public InputStream getInputStream()"
    return:
      type: "java.io.InputStream"
- uid: "com.microsoft.azure.storage.blob.SubStream.getLength()"
  id: "getLength()"
  parent: "com.microsoft.azure.storage.blob.SubStream"
  langs:
  - "java"
  name: "getLength()"
  nameWithType: "SubStream.getLength()"
  fullName: "com.microsoft.azure.storage.blob.SubStream.getLength()"
  overload: "com.microsoft.azure.storage.blob.SubStream.getLength*"
  type: "Method"
  package: "com.microsoft.azure.storage.blob"
  syntax:
    content: "public long getLength()"
    return:
      type: "long"
- uid: "com.microsoft.azure.storage.blob.SubStream.mark(int)"
  id: "mark(int)"
  parent: "com.microsoft.azure.storage.blob.SubStream"
  langs:
  - "java"
  name: "mark(int readlimit)"
  nameWithType: "SubStream.mark(int readlimit)"
  fullName: "com.microsoft.azure.storage.blob.SubStream.mark(int readlimit)"
  overload: "com.microsoft.azure.storage.blob.SubStream.mark*"
  type: "Method"
  package: "com.microsoft.azure.storage.blob"
  summary: "Marks the current position in the substream. A subsequent call to the `reset` method will reposition the stream to this stored position."
  syntax:
    content: "public synchronized void mark(int readlimit)"
    parameters:
    - id: "readlimit"
      type: "int"
      description: "the maximum limit of bytes that can be read before\n                  the mark position becomes invalid."
- uid: "com.microsoft.azure.storage.blob.SubStream.markSupported()"
  id: "markSupported()"
  parent: "com.microsoft.azure.storage.blob.SubStream"
  langs:
  - "java"
  name: "markSupported()"
  nameWithType: "SubStream.markSupported()"
  fullName: "com.microsoft.azure.storage.blob.SubStream.markSupported()"
  overload: "com.microsoft.azure.storage.blob.SubStream.markSupported*"
  type: "Method"
  package: "com.microsoft.azure.storage.blob"
  summary: "The substream wrapper class is only compatible with markable input streams and hence will always return true. This requirement is enforced in the class constructor."
  syntax:
    content: "public boolean markSupported()"
    return:
      type: "boolean"
      description: "<code>true</code>"
- uid: "com.microsoft.azure.storage.blob.SubStream.read()"
  id: "read()"
  parent: "com.microsoft.azure.storage.blob.SubStream"
  langs:
  - "java"
  name: "read()"
  nameWithType: "SubStream.read()"
  fullName: "com.microsoft.azure.storage.blob.SubStream.read()"
  overload: "com.microsoft.azure.storage.blob.SubStream.read*"
  type: "Method"
  package: "com.microsoft.azure.storage.blob"
  summary: "Reads the next byte of data from the wrapped stream. The value byte is returned as an `int` in the range `0` to `255`. If no byte is available because the end of the substream has been reached, the value `-1` is returned. This method blocks until input data is available, the end of the stream is detected, or an exception is thrown."
  syntax:
    content: "public int read()"
    return:
      type: "int"
      description: "the next byte of data, or <code>-1</code> if the end of the\n substream is reached."
  exceptions:
  - type: "java.io.IOException"
    description: "if an I/O error occurs."
- uid: "com.microsoft.azure.storage.blob.SubStream.read(byte[])"
  id: "read(byte[])"
  parent: "com.microsoft.azure.storage.blob.SubStream"
  langs:
  - "java"
  name: "read(byte[] b)"
  nameWithType: "SubStream.read(byte[] b)"
  fullName: "com.microsoft.azure.storage.blob.SubStream.read(byte[] b)"
  overload: "com.microsoft.azure.storage.blob.SubStream.read*"
  type: "Method"
  package: "com.microsoft.azure.storage.blob"
  summary: "Reads some number of bytes from the wrapped stream and stores them into the buffer array `b`. The number of bytes actually read is returned as an integer. This method blocks until input data is available, end of file is detected, or an exception is thrown.\n\nIf the length of `b` is zero, then no bytes are read and `0` is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the substream is at the end of the file, the value `-1` is returned; otherwise, at least one byte is read and stored into `b`.\n\nThe first byte read is stored into element `b[0]`, the next one into `b[1]`, and so on. The number of bytes read is, at most, equal to the length of `b`. Let *k* be the number of bytes actually read; these bytes will be stored in elements `b[0]` through `b[`*k*`-1]`, leaving elements `b[`*k*`]` through `b[b.length-1]` unaffected.\n\nThe `read(b)` method for class `SubStream` has the same effect as:\n\n```java\nread(b, 0, b.length)\n```"
  syntax:
    content: "public synchronized int read(byte[] b)"
    parameters:
    - id: "b"
      type: "byte[]"
      description: "the buffer into which the data is read."
    return:
      type: "int"
      description: "the total number of bytes read into the buffer, or\n <code>-1</code> if there is no more data because the end of\n the stream has been reached."
  exceptions:
  - type: "java.io.IOException"
    description: "If the first byte cannot be read for any reason\n                              other than the end of the file, if the wrapped stream has been closed, or\n                              if some other I/O error occurs."
- uid: "com.microsoft.azure.storage.blob.SubStream.read(byte[],int,int)"
  id: "read(byte[],int,int)"
  parent: "com.microsoft.azure.storage.blob.SubStream"
  langs:
  - "java"
  name: "read(byte[] b, int off, int len)"
  nameWithType: "SubStream.read(byte[] b, int off, int len)"
  fullName: "com.microsoft.azure.storage.blob.SubStream.read(byte[] b, int off, int len)"
  overload: "com.microsoft.azure.storage.blob.SubStream.read*"
  type: "Method"
  package: "com.microsoft.azure.storage.blob"
  summary: "Reads up to `len` bytes of data from the substream. Buffers data from the wrapped stream in order to minimize skip and read overhead. The wrappedstream will only be invoked if the readBuffer cannot fulfil the the read request. In order to ensure valid results, the wrapped stream must be marked prior to reading from the substream. This allows us to reset to the relative substream position in the wrapped stream. The number of bytes actually read is returned as an integer. All these operations are done synchronously within an intrinsic lock to ensure other concurrent requests by substream instances do not result in race conditions.\n\nThe underlying call to the read of the wrapped stream will blocks until input data is available, end of file is detected, or an exception is thrown.\n\nIf `len` is zero, then no bytes are read and `0` is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the substream is at end of file, the value `-1` is returned; otherwise, at least one byte is read and stored into `b`."
  syntax:
    content: "public synchronized int read(byte[] b, int off, int len)"
    parameters:
    - id: "b"
      type: "byte[]"
      description: "the buffer into which the data is read."
    - id: "off"
      type: "int"
      description: "the start offset in array <code>b</code>\n            at which the data is written."
    - id: "len"
      type: "int"
      description: "the maximum number of bytes to read."
    return:
      type: "int"
      description: "the total number of bytes read into the buffer, or\n <code>-1</code> if there is no more data because the end of\n the stream has been reached."
  exceptions:
  - type: "java.io.IOException"
    description: "If the first byte cannot be read for any reason\n                                   other than end of file, or if the wrapped stream has been closed, or if\n                                   some other I/O error occurs."
- uid: "com.microsoft.azure.storage.blob.SubStream.reset()"
  id: "reset()"
  parent: "com.microsoft.azure.storage.blob.SubStream"
  langs:
  - "java"
  name: "reset()"
  nameWithType: "SubStream.reset()"
  fullName: "com.microsoft.azure.storage.blob.SubStream.reset()"
  overload: "com.microsoft.azure.storage.blob.SubStream.reset*"
  type: "Method"
  package: "com.microsoft.azure.storage.blob"
  summary: "Repositions the substream position to the index where the `mark` method was last called.\n\nThe new reset position on substream does not take effect until subsequent reads."
  syntax:
    content: "public synchronized void reset()"
- uid: "com.microsoft.azure.storage.blob.SubStream.skip(long)"
  id: "skip(long)"
  parent: "com.microsoft.azure.storage.blob.SubStream"
  langs:
  - "java"
  name: "skip(long n)"
  nameWithType: "SubStream.skip(long n)"
  fullName: "com.microsoft.azure.storage.blob.SubStream.skip(long n)"
  overload: "com.microsoft.azure.storage.blob.SubStream.skip*"
  type: "Method"
  package: "com.microsoft.azure.storage.blob"
  summary: "Advances the current position of the substream by `n`. The `skip` method does not invoke the underlying `skip` method of the wrapped stream class. The actual skipping of bytes will be accounted for during subsequent substream read operations."
  syntax:
    content: "public long skip(long n)"
    parameters:
    - id: "n"
      type: "long"
      description: "the number of bytes to be effectively skipped."
    return:
      type: "long"
      description: "the actual number of bytes skipped."
references:
- uid: "java.io.InputStream"
  spec.java:
  - uid: "java.io.InputStream"
    name: "InputStream"
    fullName: "java.io.InputStream"
- uid: "long"
  spec.java:
  - uid: "long"
    name: "long"
    fullName: "long"
- uid: "java.lang.Object"
  spec.java:
  - uid: "java.lang.Object"
    name: "Object"
    fullName: "java.lang.Object"
- uid: "com.microsoft.azure.storage.blob.SubStream.SubStream*"
  name: "SubStream"
  nameWithType: "SubStream.SubStream"
  fullName: "com.microsoft.azure.storage.blob.SubStream.SubStream"
  package: "com.microsoft.azure.storage.blob"
- uid: "com.microsoft.azure.storage.blob.SubStream.getInputStream*"
  name: "getInputStream"
  nameWithType: "SubStream.getInputStream"
  fullName: "com.microsoft.azure.storage.blob.SubStream.getInputStream"
  package: "com.microsoft.azure.storage.blob"
- uid: "com.microsoft.azure.storage.blob.SubStream.getLength*"
  name: "getLength"
  nameWithType: "SubStream.getLength"
  fullName: "com.microsoft.azure.storage.blob.SubStream.getLength"
  package: "com.microsoft.azure.storage.blob"
- uid: "java.io.IOException"
  spec.java:
  - uid: "java.io.IOException"
    name: "IOException"
    fullName: "java.io.IOException"
- uid: "int"
  spec.java:
  - uid: "int"
    name: "int"
    fullName: "int"
- uid: "com.microsoft.azure.storage.blob.SubStream.read*"
  name: "read"
  nameWithType: "SubStream.read"
  fullName: "com.microsoft.azure.storage.blob.SubStream.read"
  package: "com.microsoft.azure.storage.blob"
- uid: "byte[]"
  spec.java:
  - uid: "byte"
    name: "byte"
    fullName: "byte"
  - name: "[]"
    fullName: "[]"
- uid: "com.microsoft.azure.storage.blob.SubStream.skip*"
  name: "skip"
  nameWithType: "SubStream.skip"
  fullName: "com.microsoft.azure.storage.blob.SubStream.skip"
  package: "com.microsoft.azure.storage.blob"
- uid: "com.microsoft.azure.storage.blob.SubStream.mark*"
  name: "mark"
  nameWithType: "SubStream.mark"
  fullName: "com.microsoft.azure.storage.blob.SubStream.mark"
  package: "com.microsoft.azure.storage.blob"
- uid: "com.microsoft.azure.storage.blob.SubStream.reset*"
  name: "reset"
  nameWithType: "SubStream.reset"
  fullName: "com.microsoft.azure.storage.blob.SubStream.reset"
  package: "com.microsoft.azure.storage.blob"
- uid: "boolean"
  spec.java:
  - uid: "boolean"
    name: "boolean"
    fullName: "boolean"
- uid: "com.microsoft.azure.storage.blob.SubStream.markSupported*"
  name: "markSupported"
  nameWithType: "SubStream.markSupported"
  fullName: "com.microsoft.azure.storage.blob.SubStream.markSupported"
  package: "com.microsoft.azure.storage.blob"
- uid: "com.microsoft.azure.storage.blob.SubStream.close*"
  name: "close"
  nameWithType: "SubStream.close"
  fullName: "com.microsoft.azure.storage.blob.SubStream.close"
  package: "com.microsoft.azure.storage.blob"
- uid: "java.lang.Object.wait()"
  name: "Object.wait()"
  nameWithType: "Object.wait()"
  fullName: "java.lang.Object.wait()"
- uid: "java.lang.Object.finalize()"
  name: "Object.finalize()"
  nameWithType: "Object.finalize()"
  fullName: "java.lang.Object.finalize()"
- uid: "java.io.InputStream.mark(int)"
  name: "InputStream.mark(int)"
  nameWithType: "InputStream.mark(int)"
  fullName: "java.io.InputStream.mark(int)"
- uid: "java.lang.Object.clone()"
  name: "Object.clone()"
  nameWithType: "Object.clone()"
  fullName: "java.lang.Object.clone()"
- uid: "java.io.InputStream.readNBytes(int)"
  name: "InputStream.readNBytes(int)"
  nameWithType: "InputStream.readNBytes(int)"
  fullName: "java.io.InputStream.readNBytes(int)"
- uid: "java.io.InputStream.close()"
  name: "InputStream.close()"
  nameWithType: "InputStream.close()"
  fullName: "java.io.InputStream.close()"
- uid: "java.lang.Object.wait(long)"
  name: "Object.wait(long)"
  nameWithType: "Object.wait(long)"
  fullName: "java.lang.Object.wait(long)"
- uid: "java.lang.Object.getClass()"
  name: "Object.getClass()"
  nameWithType: "Object.getClass()"
  fullName: "java.lang.Object.getClass()"
- uid: "java.lang.Object.hashCode()"
  name: "Object.hashCode()"
  nameWithType: "Object.hashCode()"
  fullName: "java.lang.Object.hashCode()"
- uid: "java.io.InputStream.markSupported()"
  name: "InputStream.markSupported()"
  nameWithType: "InputStream.markSupported()"
  fullName: "java.io.InputStream.markSupported()"
- uid: "java.lang.Object.wait(long,int)"
  name: "Object.wait(long,int)"
  nameWithType: "Object.wait(long,int)"
  fullName: "java.lang.Object.wait(long,int)"
- uid: "java.io.InputStream.nullInputStream()"
  name: "InputStream.nullInputStream()"
  nameWithType: "InputStream.nullInputStream()"
  fullName: "java.io.InputStream.nullInputStream()"
- uid: "java.io.InputStream.transferTo(java.io.OutputStream)"
  name: "InputStream.transferTo(OutputStream)"
  nameWithType: "InputStream.transferTo(OutputStream)"
  fullName: "java.io.InputStream.transferTo(java.io.OutputStream)"
- uid: "java.io.InputStream.read(byte[])"
  name: "InputStream.read(byte[])"
  nameWithType: "InputStream.read(byte[])"
  fullName: "java.io.InputStream.read(byte[])"
- uid: "java.lang.Object.notify()"
  name: "Object.notify()"
  nameWithType: "Object.notify()"
  fullName: "java.lang.Object.notify()"
- uid: "java.io.InputStream.available()"
  name: "InputStream.available()"
  nameWithType: "InputStream.available()"
  fullName: "java.io.InputStream.available()"
- uid: "java.io.InputStream.readNBytes(byte[],int,int)"
  name: "InputStream.readNBytes(byte[],int,int)"
  nameWithType: "InputStream.readNBytes(byte[],int,int)"
  fullName: "java.io.InputStream.readNBytes(byte[],int,int)"
- uid: "java.lang.Object.notifyAll()"
  name: "Object.notifyAll()"
  nameWithType: "Object.notifyAll()"
  fullName: "java.lang.Object.notifyAll()"
- uid: "java.io.InputStream.readAllBytes()"
  name: "InputStream.readAllBytes()"
  nameWithType: "InputStream.readAllBytes()"
  fullName: "java.io.InputStream.readAllBytes()"
- uid: "java.io.InputStream.skip(long)"
  name: "InputStream.skip(long)"
  nameWithType: "InputStream.skip(long)"
  fullName: "java.io.InputStream.skip(long)"
- uid: "java.lang.Object.equals(java.lang.Object)"
  name: "Object.equals(Object)"
  nameWithType: "Object.equals(Object)"
  fullName: "java.lang.Object.equals(java.lang.Object)"
- uid: "java.lang.Object.toString()"
  name: "Object.toString()"
  nameWithType: "Object.toString()"
  fullName: "java.lang.Object.toString()"
- uid: "java.io.InputStream.read()"
  name: "InputStream.read()"
  nameWithType: "InputStream.read()"
  fullName: "java.io.InputStream.read()"
- uid: "java.io.InputStream.read(byte[],int,int)"
  name: "InputStream.read(byte[],int,int)"
  nameWithType: "InputStream.read(byte[],int,int)"
  fullName: "java.io.InputStream.read(byte[],int,int)"
- uid: "java.io.InputStream.reset()"
  name: "InputStream.reset()"
  nameWithType: "InputStream.reset()"
  fullName: "java.io.InputStream.reset()"
